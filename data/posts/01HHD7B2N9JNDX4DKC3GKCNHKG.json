{
  "id": "01HHD7B2N9JNDX4DKC3GKCNHKG",
  "slug": "a-mental-model-for-styling-the-shadow-dom",
  "title": "A Mental Model for Styling the Shadow DOM",
  "description": "Writing styles for the Shadow DOM is like creating a user agent stylesheet for your custom element.",
  "publishedAt": "2023-12-11T19:58:21.865Z",
  "published": true,
  "updatedAt": "2023-12-11T22:12:05.188Z",
  "html": "<p><strong>Writing styles for the Shadow DOM is like creating a user agent stylesheet for your custom element.</strong> This is a good mental model for how to expect Shadow DOM styles to behave and for writing good styles for a custom element.</p>\n<h2 id=\"shadow-dom-styles-are-cascaded-before-the-document-styles\">Shadow DOM styles are cascaded before the document styles</h2>\n<p>Crucial to writing styles for the Shadow DOM is understanding where they fit in the cascade. It’s common to understand Shadow DOM styles as something that gets cascaded after a document’s styles, but that’s not the case. Styles written for the Shadow DOM are cascaded after the user agent and user styles. Document styles or those in the custom element’s host context override the styles you set in the Shadow DOM—not the other way around. This is why Shadow DOM styles appear to be weak which makes them similar to user agent styles. Here’s a simplified ordering of the cascade:</p>\n<ol>\n<li>User agent styles</li>\n<li>User styles (i.e. styles which relate to user preferences like font size, etc.)</li>\n<li>Shadow context styles (including layers)</li>\n<li>Document or light context styles (including layers)</li>\n<li>Inline styles</li>\n</ol>\n<p>For a more in-depth overview of the cascade, I recommend reading <a href=\"https://css-tricks.com/css-cascade-layers/\">Miriam Suzanne’s “A Complete Guide to CSS Cascade Layers.”</a></p>\n<p><strong>The apparent weakness of shadow styles is actually their strength—it’s what allows your custom element to remain extensible.</strong> With that being said, there are cases where one might need their shadow styles to prevail over those of the document. Let’s revisit a friend whose got a bad reputation.</p>\n<h2 id=\"using-important-for-its-actual-purpose\">Using <code>!important</code> for its actual purpose</h2>\n<p>The <code>!important</code> flag has a long history of abuse, so much so that we would never consider using it a good practice, would we? This is something that we need to rethink as we become the authors of custom elements.</p>\n<p><code>!important</code> allows us to denote what styles are so important about our custom element’s shadow styles that they should not be changed by consumers. Using <code>!important</code> with a shadow CSS rule for the shadow host, a slotted element, or CSS parts will prevent that rule from being changed in the host’s context.</p>\n<p>Once we understand that our shadow styles act more like a user agent stylesheet where their weakness is a strength and that we can reclaim <code>!important</code> for its proper use, we’re ready to write Shadow DOM styles for our custom elements.</p>\n<h2 id=\"set-good-defaults-and-embrace-extensibility\">Set good defaults and embrace extensibility</h2>\n<p>I’ve often seen the advice to not write styles for slotted elements at all (i.e. using the <code>::slotted()</code> selector) and I don’t think that’s good advice. With this mental model I’ve presented above, I hope you can see your shadow styles are more about providing a good usable default that is designed to be overridden or extended. Embrace the use of slots and parts in your custom element designs, and don’t be afraid to style them.</p>\n<p>Great styles will help communicate what affordances a custom element provides. For example, if you have a custom element that decorates a <code>&#x3C;button></code> element as a toggle button using the <code>aria-pressed</code> attribute, provide shadow styles for both of those states:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">::slotted</span>(<span class=\"hljs-selector-tag\">button</span><span class=\"hljs-selector-attr\">[aria-pressed=<span class=\"hljs-string\">\"true\"</span>]</span>) {\n  <span class=\"hljs-comment\">/* Styles for when the button is pressed */</span>\n}\n\n<span class=\"hljs-selector-pseudo\">::slotted</span>(<span class=\"hljs-selector-tag\">button</span><span class=\"hljs-selector-attr\">[aria-pressed=<span class=\"hljs-string\">\"false\"</span>]</span>) {\n  <span class=\"hljs-comment\">/* Styles for when the button isn’t pressed */</span>\n}\n</code></pre>\n<p>If there’s only one ways an affordance can be visually communicated, you can use <code>!important</code> to ensure that isn’t overridden. You can even use <code>!important</code> on a rule, but use custom properties to allow for more constrained modification of the rule.</p>\n<h2 id=\"resetting-a-custom-elements-shadow-styles-is-very-easy\">Resetting a custom element’s shadow styles is very easy</h2>\n<p>Maybe you think these default styles just introduce extra work for the consumer to override? Well, it’s actually not very difficult to revert all of the shadow styles for an element.</p>\n<p>Say we have a slotted button that has some default styles from the Shadow DOM. We can target the element and set <code>all: revert</code> and sure enough we’re back to the user agent styles for that element. The one exception is those styles that we’ve deemed important with the <code>!important</code> flag. I hope you can see this as a positive. We’ve got an incredible way of resetting an element while still respecting what’s vital to it. Reset without fear! <a href=\"https://codepen.io/knowler/pen/OJdGxoq\">Check out this pen of resetting shadow styles in action</a> or see a reduced example of it below:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n\ttoggle-<span class=\"hljs-selector-tag\">button</span> <span class=\"hljs-selector-tag\">button</span> {\n\t\t<span class=\"hljs-attribute\">all</span>: revert;\n\t}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">toggle-button</span>></span>\n\t<span class=\"hljs-comment\">&#x3C;!-- Using the Declarative Shadow DOM for visualizing the example --></span>>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">shadowrootmode</span>=<span class=\"hljs-string\">\"open\"</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n\t\t\t<span class=\"hljs-selector-pseudo\">::slotted</span>(<span class=\"hljs-selector-tag\">button</span>) {\n\t\t\t\t<span class=\"hljs-comment\">/* Will be overridden by revert */</span>\n\t\t\t\t<span class=\"hljs-attribute\">font-family</span>: system-ui;\n\t\t\t\t<span class=\"hljs-attribute\">font-weight</span>: <span class=\"hljs-number\">600</span>;\n\t\t\t\t<span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1em</span>;\n\t\t\t\t<span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0.5em</span>;\n\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0.5em</span>;\n\t\t\t}\n\n\t\t\t<span class=\"hljs-comment\">/* The following will not be overridden by revert (but provides some ability to be modified) */</span>\n\n\t\t\t<span class=\"hljs-selector-pseudo\">::slotted</span>(<span class=\"hljs-selector-tag\">button</span>) {\n\t\t\t\t<span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">0.125em</span> solid <span class=\"hljs-built_in\">var</span>(--color-foreground) <span class=\"hljs-meta\">!important</span>;\n\n\t\t\t\t<span class=\"hljs-comment\">/* Custom properties are not included in `all`, so these are safe. */</span>\n\t\t\t\t<span class=\"hljs-attr\">--color-foreground</span>: DeepPink;\n\t\t\t\t<span class=\"hljs-attr\">--color-background</span>: White;\n\t\t\t}\n\n\t\t\t<span class=\"hljs-selector-pseudo\">::slotted</span>(<span class=\"hljs-selector-tag\">button</span><span class=\"hljs-selector-attr\">[aria-pressed=<span class=\"hljs-string\">\"true\"</span>]</span>) {\n\t\t\t\t<span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--color-foreground) <span class=\"hljs-meta\">!important</span>;\n\t\t\t\t<span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--color-background) <span class=\"hljs-meta\">!important</span>;\n\t\t\t}\n\n\t\t\t<span class=\"hljs-selector-pseudo\">::slotted</span>(<span class=\"hljs-selector-tag\">button</span><span class=\"hljs-selector-attr\">[aria-pressed=<span class=\"hljs-string\">\"false\"</span>]</span>) {\n\t\t\t\t<span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--color-background) <span class=\"hljs-meta\">!important</span>;\n\t\t\t\t<span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--color-foreground) <span class=\"hljs-meta\">!important</span>;\n\t\t\t}\n\t\t</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"button\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">aria-pressed</span>=<span class=\"hljs-string\">\"true\"</span>></span>Dark Mode<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">toggle-button</span>></span>\n</code></pre>\n<h2 id=\"but-what-about-design-system-components\">But what about design system components?</h2>\n<p>A popular use case for custom elements is implementing a library of design system components. The mental model I’ve presented above works really well for introducing new UI primitives where extensibility is vital for reusability. Design system components don’t allow for such free-handed extensibility: visual design constraints are crucial. Is this use case at odds with the mental model? I don’t think so.</p>\n<p>If you’re using the Shadow DOM at all, understanding it how I’ve explained will serve you. It might even help you identify when you’ve got a bad expectation of it and steer you towards a more appropriate solution. I’ve got some techniques that I’ll share in a future post for how to use the Shadow DOM to enforce design constraints while allowing the use of slots and parts—and what’s even greater news is that some of the techniques don’t even require the Shadow DOM at all. You can have Shadow DOM like isolation in the Light DOM. Stay tuned…</p>",
  "webmentions": [
    "bf207f91-abfd-4e07-ae45-09d697b0a5ff",
    "ac9fa926-1d0f-46ec-bc09-8966744bfa04",
    "c7b65fe2-333a-4662-be38-5886b7fb33f6",
    "924091a7-43b2-4d44-b24f-988ddbeb90f2",
    "da2a82ac-1cb7-4b62-8ae8-51cae798fb26"
  ]
}