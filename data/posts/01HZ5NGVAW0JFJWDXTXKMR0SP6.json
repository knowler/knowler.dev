{
  "id": "01HZ5NGVAW0JFJWDXTXKMR0SP6",
  "slug": "on-slot-elements",
  "title": "On <slot> elements",
  "description": "Or not your grandma’s slots.",
  "publishedAt": "2024-05-30T21:12:01.116Z",
  "published": true,
  "updatedAt": "2024-05-31T14:20:56.746Z",
  "html": "<p>Slots are a templating concept that long predate their inclusion in the Web platform. Many templating languages contain some form of slotting whether it be simple or more complex (i.e. there are named slots). For example, JSX has <code>children</code>, Laravel Blade has <code>$slot</code> or <code>@yield</code>, Pug has <code>block</code>, and so on. Generally these allow us to create composable HTML trees. Their final result is a single static HTML tree.</p>\n<h2 id=\"slots-on-the-web-are-different\">Slots on the Web are different</h2>\n<p>The <code>&#x3C;slot></code> element’s difference is similar to how variables in Sass are different from CSS custom properties: the former are static which means they are compiled away and the resulting CSS just contains the final value. The latter are dynamic: they remain active at runtime and changing the value of a custom property will affect any use of it. If you’ve used custom properties in CSS you might know that their being dynamic makes them extremely powerful. Slots likewise are dynamic.</p>\n<p>Slots are a feature of the Shadow DOM. An element that uses the Shadow DOM doesn’t just have a shadow tree. Its own light tree remains active. The <code>&#x3C;slot></code> element allows elements within an element’s light tree to display within the shadow tree.</p>\n<p>The following code snippet uses the Declarative Shadow DOM to visualize the element’s shadow tree. When a browser parses HTML, it will automatically attach a declarative shadow tree to their parent element, provided that their parent element supports the Shadow DOM. The resulting DOM will not include the <code>&#x3C;template></code> element as it is inert and no longer serves any purpose.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">my-element</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">shadowrootmode</span>=<span class=\"hljs-string\">\"open\"</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Fallback content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Slotted content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">my-element</span>></span>\n</code></pre>\n<p>In this example, <code>&#x3C;my-element></code> will have two trees: a <em>light</em> one and a <em>shadow</em> one. The following is the resulting shadow tree:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Fallback content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n</code></pre>\n<p>And now the resulting light tree:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Slotted content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n</code></pre>\n<p>Unlike the declarative shadow root’s <code>&#x3C;template></code> element, the <code>&#x3C;slot></code> element remains because it still has a purpose. That purpose is to keep an active connection between the two trees. If the shadow host’s light tree changes, its content will be slotted into the corresponding slot in the shadow tree. It doesn’t actually move the slotted element; the slotted element is just projected into the shadow tree’s structure within its assigned slot.</p>\n<aside><h3 id=\"a-note-on-whitespace\">A note on whitespace</h3><p>Please note that in these code snippets I have extra whitespace surrounding the declarative shadow root. In reality, whitespace matters for slotting and so in the previous code snippet with the <code>&#x3C;my-element></code> element, if the slotted content was removed, the fallback still wouldn’t show because there is extra whitespace around the <code>&#x3C;template></code> element. To display the fallback content, you would need to write your element with its declarative shadow root like this:</p><pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">my-element</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">shadowrootmode</span>=<span class=\"hljs-string\">\"open\"</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Fallback content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">my-element</span>></span>\n</code></pre><p>Not very pretty. This is definitely a paper cut, but it’s also not a problem with how the <code>&#x3C;slot></code> element was designed and has more to do with how HTML works. You might wonder, “but why can’t it just ignore the extra surrounding whitespace?” Consider this Shadow DOM tree:</p><pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">pre</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">pre</span>></span>\n</code></pre><p>In this situation, slotted whitespace is totally relevant. With that said, I do hope we eventually get some way to choose if we want slots to ignore whitespace as it would help in situations were it is irrelevant which is likely most of the time.</p></aside>\n<h2 id=\"slot-elements-in-the-composed-tree\"><code>&#x3C;slot></code> elements in the composed tree</h2>\n<p>Sometimes web frameworks or templating tools—there is a handful of them— will use the <code>&#x3C;slot></code> element for slotting when they render an element or component’s content. In some cases, the resulting HTML will attempt to match something we call the <i>composed tree</i>.</p>\n<p>The <dfn>composed tree</dfn> is a flattened representation of the composition. It’s useful for understanding the visual product (i.e. the boxes) or how CSS inheritance might work between elements in the tree.</p>\n<p>For the above code snippets, the composed tree (including the host) would look like this:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">my-element</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>Slotted content<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">my-element</span>></span>\n</code></pre>\n<p>What’s crucial to understand is <strong>this composed tree isn’t a real DOM tree: the slotted content element isn’t actually moved into the shadow tree.</strong> We still need the appropriate CSS selectors to style across the shadow boundary (e.g. the <code>::slotted()</code> pseudo-element).</p>\n<p>Furthermore, <strong>even in the composed tree <code>&#x3C;slot></code> elements continue to have a purpose</strong> and removing them would be inaccurate. <code>&#x3C;slot></code> elements are not just a vehicle for their content, they are a part of the structure they enable both functionally and visually.</p>\n<h2 id=\"slot-elements-are-relevant-for-styling\"><code>&#x3C;slot></code> elements are relevant for styling</h2>\n<p>Since <code>&#x3C;slot></code> elements are not inert like the <code>&#x3C;template></code> element is they become relevant for styling. This might be surprising since it certainly doesn’t seem like they can be styled, but that’s because their default <code>display</code> property is set to <code>contents</code> by the user agent. This means they won’t generate a box for themself and by default they only will serve as a conduit of inheritance for any fallback content they contain or slotted elements assigned to them.</p>\n<p>This is a great default since it also allows slotted elements to participate in grid or flexbox layouts of the <code>&#x3C;slot></code> element’s parent element which might be the shadow host. However, since their user agent style of <code>display: contents</code> isn’t flagged as <code>!important</code>, authors can style them however they choose.</p>\n<p>Is that a bad idea?</p>\n<p>Well, Chrome certainly doesn’t seem to think so as it styles the <code>&#x3C;details></code> element’s content slot when its closed. Don’t believe me? Just find a <code>&#x3C;details></code> element on the web, pop open devtools and observe the shadow tree as you open and close the element. The <code>#details-content</code> <code>&#x3C;slot></code> element has the following inline styles when it’s closed: <code>display: block; content-visibility: hidden</code>.</p>\n<p>It can be very useful to target a <code>&#x3C;slot></code> element for styling as the styles can be inherited by any fallback content or slotted content. I’ve found it particularly useful to even change the <code>display</code> property of a <code>&#x3C;slot></code> element so I can change its layout or just reduce the amount of elements in my shadow tree. Heck, I’ll even make a <code>&#x3C;slot></code> element a CSS part so that consumers of my custom element can style it too.</p>\n<h2 id=\"to-be-continued-hopefully\">To be continued (hopefully)</h2>\n<p>I have more to say about <code>&#x3C;slot></code> elements, but I’m going to stop here for today. I think I’ve made a good case demonstrating that <code>&#x3C;slot></code> elements are relevant visually. Next time I’d like to dig more into how they are “alive.”</p>"
}
