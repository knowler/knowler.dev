{
  "id": "01HZSS5PGXW4VEND29M7HS5P27",
  "slug": "please-keep-your-hands-arms-and-legs-inside-the-custom-element",
  "title": "Please keep your hands, arms, and legs inside the custom element",
  "description": "How to avoid accidental dismemberment, death, and some thoughts on sciophobia",
  "publishedAt": "2024-06-07T16:40:38.685Z",
  "published": true,
  "html": "<p>A principle I have for custom elements is this: “please keep your hands,\narms, and legs inside the vehicle.” This comes from an announcement\ntypically played at amusement parks and it is basically a warning to\navoid accidental dismemberment (or death).</p>\n<p>How does this relate to custom elements?</p>\n<p><em>Ideally</em>, <strong>creating</strong> or <strong>connecting</strong> a custom element should not\ncreate additional attributes on itself or introduce more elements within\nthe same context (including children). Further, anything that updates\nquickly should only do so within an isolated context (e.g. the shadow\ntree or a constructed stylesheet).</p>\n<p>The main reason why is because this is how HTML itself works. Adding an\nelement in HTML doesn’t automatically spawn attributes or children. Yes,\nin programmatic contexts you can add those yourself, but that always\nhappens <em>after</em> the element is created and not automatically. There are\nsome cases where stateful changes can cause attributes to appear\n(perhaps unnecessarily in the case of the <code>&#x3C;details></code> element — a\npseudo-class seems more appropriate), but those seem to be the exception\nand not the rule.</p>\n<p>The next reason is admittedly more of a hypothesis, but it has to do\nwith <code>MutationObserver</code>s and perhaps even CSS. Yes, some attribute or\nelement additions might be instanteous, but if you’re doing something\nlike very quickly updating a <code>style</code> attribute (e.g. perhaps with\npointing-device coordinates) that could trigger a <code>MutationObserver</code> if\nyou’re not careful and, remember, you’re not always in control of\nthose. <small>I might revisit this point when I can do some testing.</small></p>\n<p>The final reason is that what you expose becomes your API. The visible\nparts of a custom element can be interpretted as an invitation to change\nthose things and that might not work well if you depend on them being\ncontrolled internally. Further, any attribute that’s exposed becomes a\npotential target for CSS or DOM query selectors.</p>\n<p>I’m not dogmatic about this. There are cases when we can legitimately\nneed to set an attribute (e.g. <code>tabindex</code> or certain <code>aria-</code> attributes\nnot included in <code>ElementInternals</code>). Sometimes you’re supporting a\nbrowser that doesn’t fully support CSS custom state and, ya, you gotta\ndo what you gotta do. But I believe that goal is that you will not need\nto do these things and that the Web Components APIs will eventually\ncustom elements exactly the same way built-in HTML elements works.</p>\n<h2 id=\"sciophobia\">Sciophobia</h2>\n<p>I realize this flies in the face of how light DOM-only custom elements\nare built. I’m not trying to tell you to stop what your doing. You do\nyou. For me, the eventual goal of the Web Components APIs is to make\nsomething like this possible:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">site-header</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">site-header</span>></span>\n</code></pre>\n<p>Or…</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">rich-text</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">rich-text</span>></span>\n</code></pre>\n<p>These custom element should be able to be semantic, focusable,\nlabellable, stateful, capable of form participation, complexly\nvisual, selectable, etc. without any additional attributes or elements\nwithin the context it’s used. Just one element — nothing else. For me,\nthat’s when I know that we have arrived at the full realization of\ncustom elements, because that’s how built-in elements work.</p>\n<p>Web Components APIs like the Shadow DOM, <code>ElementInternals</code>, or CSS custom\nstate are the steps towards getting there. And yes, there is room to\nimprove them and other steps necessary (e.g. <a href=\"https://github.com/WICG/aom/blob/751bd5e20c457262f996909dc7e92a14345dd79c/reference-target-explainer.md\">cross-root ARIA</a> or\nimproved cross-root styling capabilities and declarative custom\nelements), but I think we’ve missed the point of what custom elements\ncan be when we settle with what works today. The Shadow DOM might not be\nthe best choice for many things today, but please do not wholly dismiss\nit because of that. It’s a crucial piece of where we’re going.</p>"
}
