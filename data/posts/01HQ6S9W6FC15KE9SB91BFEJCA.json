{
  "id": "01HQ6S9W6FC15KE9SB91BFEJCA",
  "slug": "declarative-custom-elements-should-take-inspiration-from-css",
  "title": "Declarative Custom Elements Should Take Inspiration From CSS",
  "description": "Why I think it’s worth approaching declarative custom elements the same way CSS solved stylings for HTML.",
  "publishedAt": "2024-02-21T21:31:46.767Z",
  "published": true,
  "updatedAt": "2024-02-21T23:54:01.920Z",
  "html": "<p>I’ll admit that I’m not fully read on this topic and that makes it a bit overwhelming to participate in this discussion. Nevertheless, I had a weird idea for it a while ago and I’d like to share it or at least write it on my own platform so that it doesn’t get lost the annals of some Discord channel.</p>\n<h2 id=\"declarative-custom-elements-in-a-nutshell\">Declarative Custom Elements in a nutshell</h2>\n<p>As of yesterday, the Declarative Shadow DOM is now available in all browsers with its addition to Firefox. This is great. The Shadow DOM is no longer restricted to JavaScript. This declarative form is still quite limited. It mostly serves as a way to either avoid the dreaded <em>flash of unstyled content</em> and to do less work with JavaScript. It does nothing to actually define a custom element and further if you were to use this to server render all of your custom elements that use the Shadow DOM, it would mean you need to include all the CSS in each tag (or use a <code>&#x3C;link></code> tag which can be problematic, or so I’ve heard).</p>\n<p>Enter <strong>Declarative Custom Elements</strong>. It’s a proposed way to declaratively define a custom element without JavaScript in your HTML. This would ultimately mean that you could use your custom elements without needing to server render their individual content and they would work in a limited way. You would still need JavaScript for a whole lot of functionality, but a lot of the work you might do to set up a custom element’s shadow root (i.e. the markup and styles) would be taken care of.</p>\n<p>I’m not going to get into how this relates to HTML modules or anything like that—I don’t fully understand it and it’s not relevant. What I want to focus on is syntax we use to spell out these definitions.</p>\n<h2 id=\"do-we-use-an-htmlxml-like-syntax-to-do-this\">Do we use an HTML/XML like syntax to do this?</h2>\n<p>When we think <em>declarative</em> and <em>custom elements</em>, immediately we jump to using HTML (or an XML-like) syntax to achieve this. This would require a significant extension of HTML. Further, are the ergonomics of HTML or XML up to the task? Are we selling what we could do with a JavaScript-free solution short?</p>\n<p>Now, before someone brings up <em>XSLT</em>—yes, I know that exists, but please try to entertain what I’m saying, otherwise, close this tab.</p>\n<h2 id=\"lets-talk-about-styling\">Let’s talk about styling</h2>\n<p>Wait, <em>what does styling have to do with this?</em> Well, nothing really. I do think it’s worth exploring how CSS solved issues of styling HTML.</p>\n<p>As the kids say, <em>in the late 20th century</em>, you could style your HTML was with attributes and even elements. There was a <code>&#x3C;font></code> element. There was a <code>&#x3C;center></code> element. There were <code>color</code>, <code>bgcolor</code>, <code>align</code>, <code>rightmargin</code> attributes. All deprecated now, but when I was first learning web development in the mid-2000s some of these were still in use and as a beginner reading outdated resources, I even used some until I realized the power of CSS (and browsers deprecated them).</p>\n<p>Anyway, using attributes and elements for styling was very limiting. CSS changed that by separating the concern of styling which meant that you could use the same rules for different markup without modifying the markup in every place it was used.</p>\n<h2 id=\"what-if-we-used-a-different-declarative-option\">What If we used a different declarative option?</h2>\n<p>I think that a CSS-like syntax (read: <strong>not for styling</strong>) could be useful for creating element definitions as the problem that CSS solves for styling HTML seems strikingly similar to the problem of setting up a shadow root for a custom element. Yes, CSS can’t create <em>elements</em>. What CSS is great at matching selectors to a list of properties, which makes it helpful for solving the issue of setting the values of attributes in a dynamic way.</p>\n<h2 id=\"what-this-could-look-like-an-example\">What this could look like? An Example…</h2>\n<p>Something I always test when using a templating language is how easy it is to create a navigation link that can indicate it’s the current page. I usually don’t create custom elements for these, since I don’t want them to require JavaScript. But if there were a way to do that declaratively, then I might entertain using an API like this:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"/\"</span>></span>Home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav-link</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"/about\"</span>></span>About<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav-link</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav-link</span> <span class=\"hljs-attr\">to</span>=<span class=\"hljs-string\">\"/contact\"</span>></span>Contact<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav-link</span>></span>\n</code></pre>\n<p>Underneath, I’d want these to translate to something like:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span> <span class=\"hljs-attr\">aria-current</span>=<span class=\"hljs-string\">\"page\"</span> <span class=\"hljs-attr\">part</span>=<span class=\"hljs-string\">\"link\"</span>></span>Home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n</code></pre>\n<p>And give me a declarative selector to style it with:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">nav</span>-link:<span class=\"hljs-built_in\">state</span>(current)::<span class=\"hljs-built_in\">part</span>(link) {\n\t<span class=\"hljs-attribute\">background-color</span>: DeepPink;\n\t<span class=\"hljs-attribute\">color</span>: Black;\n}\n</code></pre>\n<p>Here’s how I think this could look:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!-- This builds off the existing declarative shadow DOM syntax --></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">defines</span>=<span class=\"hljs-string\">\"nav-link\"</span> <span class=\"hljs-attr\">shadowrootmode</span>=<span class=\"hljs-string\">\"open\"</span>></span>\n\t<span class=\"hljs-comment\">&#x3C;!-- Our template’s base markup. --></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">part</span>=<span class=\"hljs-string\">\"link\"</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n\n\t<span class=\"hljs-comment\">&#x3C;!--\n\t\tI want to indicate that these styles should be an adopted stylesheet\n\t\trather than included along with the markup of every shadow root.\n\t--></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">adopted</span>></span><span class=\"css\">\n\t\t<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[aria-current=<span class=\"hljs-string\">\"page\"</span>]</span> {\n\t\t\t<span class=\"hljs-attribute\">text-decoration</span>: none;\n\t\t\t<span class=\"hljs-attribute\">color</span>: inherit;\n\t\t}\n\t</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n\n\t<span class=\"hljs-comment\">&#x3C;!--\n\t\tI’m using a style tag here for *just* syntax highlighting.\n\t\tFor the love all things good: this is not for styling though.\n\t--></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">internals</span>></span><span class=\"css\">\n\t\t<span class=\"hljs-comment\">/* The syntax is still CSS-like though even though its not for styling */</span>\n\n\t\t<span class=\"hljs-keyword\">@attribute</span> to {\n\t\t\tsyntax: <span class=\"hljs-string\">\"&#x3C;url>\"</span>;\n\t\t\tinitial-value: none;\n\t\t\tobserved: true;\n      <span class=\"hljs-comment\">/* Perhaps there could be a global registery for attributes these too that works with a custom attributes registry. */</span>\n\t\t}\n\n\t\t<span class=\"hljs-selector-tag\">a</span> {\n\t\t\t<span class=\"hljs-comment\">/* Since the `to` attribute is observed, this is now bound. */</span>\n\t\t\thref: <span class=\"hljs-built_in\">host-attribute</span>(to);\n\t\t}\n\n\t\t<span class=\"hljs-comment\">/* This works like a container style query */</span>\n\t\t<span class=\"hljs-keyword\">@host</span> attribute(<span class=\"hljs-attribute\">to</span>: location.path) {\n\t\t\t<span class=\"hljs-selector-pseudo\">:host</span> {\n\t\t\t\t<span class=\"hljs-comment\">/* Maybe you could set element’s custom state (i.e. `nav-link:state(current)`)  */</span>\n\t\t\t\tstate-set: current;\n\t\t\t}\n\n\t\t\t<span class=\"hljs-comment\">/* Most importantly, you could use this to set attributes for other elements in your shadow root */</span>\n\t\t\t<span class=\"hljs-selector-tag\">a</span> {\n\t\t\t\taria-current: page;\n\t\t\t}\n\t\t}\n\n    <span class=\"hljs-comment\">/*\n      Perhaps you could even use `@media` here too to have media query\n      specific rules (it maps to `window.matchMedia`, right?)\n    */</span>\n\t</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span>\n</code></pre>\n<p>As you can see, the idea is to use an additional tag, perhaps <code>&#x3C;internals></code> to declaratively bind the host element’s attributes to attributes for elements within the shadow root and the element’s custom state (i.e. CSS Custom State also known by its JavaScript API name <code>CustomStateSet</code>). Since CSS has a number of features like media queries or container queries, some form of these could be helpful for describing what should happen when an custom element is in a particular state.</p>\n<h2 id=\"why\">Why?</h2>\n<p>You might wonder, why do this with a CSS-like language? Isn’t the point of not using JS so that we can do this HTML? If we’re going to do it with a CSS-like language, why don’t we just use JavaScript?</p>\n<p>The main reason is that there are a lot more API overlaps between CSS and JavaScript. I don’t think it makes sense to recreate all of those in HTML. Our declarative custom elements aren’t going to be expressive as they could otherwise be, but why limit ourselves to what can be expressed with HTML or XML.</p>\n<p>CSS syntax is already familiar and developers already understand its selectors. They even use them with their JavaScript.</p>\n<p>CSS has limits that JavaScript does not. It can’t do quite as much as JavaScript can do. This makes it more ideal than running JavaScript.</p>\n<p>So, why not fork off of something that’s already declarative, albeit limited in what it can do (that’s a positive for this situation, because JavaScript is heavy and can maybe do <em>too</em> much). The two languages: this <em>custom element defintion language</em> and CSS could be mutually beneficial to each other as well as each grows as well.</p>\n<h2 id=\"closing-words\">Closing words</h2>\n<p>Anyway, that’s my two cents. Let me know what you think. Or don’t.</p>"
}