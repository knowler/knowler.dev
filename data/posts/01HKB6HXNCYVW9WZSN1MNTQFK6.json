{
  "id": "01HKB6HXNCYVW9WZSN1MNTQFK6",
  "slug": "so-you-want-to-encapsulate-your-styles",
  "title": "So, you want to encapsulate your styles?",
  "description": "What is style encapsulation and how you can you achieve it without the Shadow DOM?",
  "publishedAt": "2024-01-04T21:37:32.332Z",
  "published": true,
  "webmentions": [
    "a3ca2ed7-3eb5-4eb8-b78d-3f0985b75edc"
  ],
  "updatedAt": "2024-02-21T05:28:42.136Z",
  "html": "<p>The Shadow DOM allows us to encapsulate our styles. What does that mean?</p>\n<ol>\n<li>\n<p>Elements within a shadow tree are isolated and cannot be selected by styles set outside of the tree.</p>\n</li>\n<li>\n<p>Styles set for the shadow tree are scoped to the elements within the tree.</p>\n</li>\n</ol>\n<h2 id=\"how-can-styles-cross-the-shadow-boundary\">How can styles cross the shadow boundary?</h2>\n<p>Now, there are a few ways that styles can cross the boundary between the shadow tree and its outside context (known as the host’s context):</p>\n<ol>\n<li>\n<p>Inheritance: the host element of the shadow tree is not within the tree (surprise!). This means that it can be selected from the outside and be styled in that way. The shadow tree inherits its styles from the host element. This means that any property that inherits will inherit from the outside context. Some properties such as <code>font-family</code> or <code>color</code> inherit by default for many elements. Unregistered custom properties do this as well. People often refer to this as “piercing the Shadow DOM.”</p>\n</li>\n<li>\n<p>The <code>:host</code> pseudo-class and <code>:host()</code> pseudo-class function can be used to select the host element from inside the shadow tree. You can use the function to conditionally apply styles to elements within the tree when the host matches a particular selector.</p>\n</li>\n<li>\n<p>This selector is likely being dropped from the spec: the <code>:host-context()</code> pseudo-class can be used to apply styles to the host element or to elements within the tree when the host is used in a specific context. The function matches an ancestor with a simple selector.</p>\n</li>\n<li>\n<p>The <code>::slotted()</code> pseudo-element function allows us to select slotted elements from the host element’s light tree. Those elements are still subject to the styles of the host’s context. The shadow tree’s styles are cascaded before the host context’s styles and so any styles set with <code>::slotted()</code> will be weaker than those other styles. The only way to “win” this fight is <code>!important</code> and that completely blocks styling from outside the shadow tree for whatever property it’s applied to.</p>\n<ul>\n<li>Instead of inheriting directly from the host, slotted elements inherit from the slot element they are assigned to. That slot element being a part of the shadow tree, eventually does inherit from the host element, but this is just one thing to keep in mind.</li>\n</ul>\n</li>\n<li>\n<p>The <code>::part()</code> pseudo-element function allows the host’s context to select elements denoted as CSS parts using the <code>part</code> attribute in the shadow tree. Again, since the shadow tree’s styles are cascaded before the host’s context, the host’s context styles will win unless the <code>!important</code> flag is used on the styles within the shadow tree.</p>\n<ul>\n<li>Again, remember inheritance: since a part is what its children inherit from, applying styles with the <code>::part()</code> selector is one way you can indirectly style elements within a shadow tree.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"limitations-of-styling-the-shadow-dom\">Limitations of styling the Shadow DOM</h2>\n<p>Due to their nature of being cascaded before the host context’s styles, (which is directly after the user agent and user styles), styles set for a shadow tree cannot share styles with other shadow trees. This can be quite frustrating as it’s often desirable to reset elements or to provide some default elements for a document that one might want to be used even within the shadow tree.</p>\n<p>Another apparent limitation is the the weakness of Shadow DOM styles in situations where styles are allowed to cross the boundary. For better or for worse, we have a generation of web developers who have to conditioned to think <code>!important</code> is bad (and often, rightly so) which causes them to miss out on its usefulness in this scenario.</p>\n<p>Lastly, for slotted elements and for parts, the corresponding selectors only allow selecting the elements themselves and not their descendants. This can be extremely limiting, especially for form related elements which often require certain nested structures.</p>\n<p>So, what do we do? The Shadow DOM is our only avenue for style encapsulation, right?</p>\n<h2 id=\"style-encapsulation-without-the-shadow-dom\">Style encapsulation without the Shadow DOM</h2>\n<p>While there have always been ways of “encapsulating styles” in CSS, none of them have been quite the same as how the Shadow DOM works. Complex selectors can be used to “scope styles” to an ancestor. That falls short when multiple ancestors target the same elements: it becomes a battle of the cascade and specificity.</p>\n<h3 id=\"using-cascade-layers-to-isolate-our-styles\">Using cascade layers to isolate our styles</h3>\n<p>Cascade layers can be used to effectively isolate our styles from the rest of the document’s styles. Remember, a shadow root’s styles are cascaded right after the user-agent and user styles. If we put our component’s styles in the first cascade layer of a document, then we’ve got the same environment for our styles.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@layer</span> components;\n\n<span class=\"hljs-keyword\">@layer</span> components {\n\t<span class=\"hljs-attribute\">icon</span>-<span class=\"hljs-selector-tag\">button</span> <span class=\"hljs-selector-tag\">button</span> {\n\t\t<span class=\"hljs-comment\">/* Button styles */</span>\n\t}\n}\n</code></pre>\n<p>But, that’s not quite all since styles in subsequent layers can still select our elements. Remember, how <code>!important</code> works in the Shadow DOM? We can use that the same way here. Using <code>!important</code> in a layer will prevent subsequent layers from styling whatever property of the element we apply it to.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@layer</span> components;\n\n<span class=\"hljs-keyword\">@layer</span> components {\n\t<span class=\"hljs-attribute\">icon</span>-<span class=\"hljs-selector-tag\">button</span> <span class=\"hljs-selector-tag\">button</span> {\n\t\t<span class=\"hljs-attribute\">color</span>: DeepPink <span class=\"hljs-meta\">!important</span>;\n\t}\n}\n\n<span class=\"hljs-attribute\">icon</span>-<span class=\"hljs-selector-tag\">button</span> <span class=\"hljs-selector-tag\">button</span> {\n\t<span class=\"hljs-attribute\">color</span>: Wheat <span class=\"hljs-meta\">!important</span>; <span class=\"hljs-comment\">/* important for good measure */</span>\n}\n</code></pre>\n<p>Now it can be quite tedious to apply this to every single property we’ve set a value for. We can make use of a sub-layer to effectively make the child element of our component work as if they were an element in a shadow tree.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@layer</span> components;\n\n<span class=\"hljs-keyword\">@layer</span> components {\n\t<span class=\"hljs-attribute\">icon</span>-<span class=\"hljs-selector-tag\">button</span> <span class=\"hljs-selector-tag\">button</span> {\n\t\t<span class=\"hljs-keyword\">@layer</span> styles {\n\t\t\t<span class=\"hljs-attribute\">color</span>: DeepPink;\n\t\t}\n\n\t\t<span class=\"hljs-attribute\">all</span>: revert-layer <span class=\"hljs-meta\">!important</span>;\n\t}\n}\n\n<span class=\"hljs-attribute\">icon</span>-<span class=\"hljs-selector-tag\">button</span> <span class=\"hljs-selector-tag\">button</span> {\n\t<span class=\"hljs-attribute\">font-family</span>: Comic Sans;\n\t<span class=\"hljs-attribute\">color</span>: Wheat <span class=\"hljs-meta\">!important</span>; <span class=\"hljs-comment\">/* important for good measure */</span>\n}\n</code></pre>\n<p>What’s happening here is that we are reverting the “unlayered” styles of the <code>components</code> layer back to the previous layer. Unlayered styles come after layers, so in this case the previous layer of the “unlayered” styles of the <code>components</code> layer is its <code>styles</code> sub-layer (i.e. <code>components.styles</code>). That’s all a bit hard to understand without a visual, so here’s the order of the layers in our example:</p>\n<ol>\n<li>\n<p>components</p>\n<ol>\n<li>styles\n<ul>\n<li>This is the previous layer (i.e. what the styles are being reverted to).</li>\n</ul>\n</li>\n<li>unlayered\n<ul>\n<li><code>revert-layer</code> is applied on this sub-layer.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>unlayered</p>\n</li>\n</ol>\n<p>Using <code>!important</code> in tandem with <code>revert-layer</code> prevents all subsequent layers from styling whatever property it was set on. And since we used the <code>all</code> selector, that means everything except custom properties and some internationalization related properties.</p>\n<p>Now that might seem heavy handed, but what we’ve got the basis for is practically the same as what we get with the Shadow DOM. Use <code>all: revert-layer !important</code> for any element that you want to consider “within the shadow tree” and therefore isolated from selection outside the tree. Elements without the rule will work the same as slotted or CSS part elements work. The only difference is that we have one tree and not two, which honestly is easier to reckon with.</p>\n<h3 id=\"improving-our-scoping-with-scope\">Improving our scoping with <code>@scope</code></h3>\n<p>Since we are still partly encapsulating our styles with a complex selector, we still have the cascade and specificity to deal with in the <code>components</code> layer. In practice this means we might have difficulty composing two components that target the same descendant. Whatever comes later in the cascade—provided they have equal specificity—will win.</p>\n<p>The <code>@scope</code> rule is still being implemented in browsers. As I write this, Chromium browsers are the only browsers which have it in stable and it is available through a flag in Safari Technology Preview.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@layer</span> components {\n\t<span class=\"hljs-keyword\">@scope</span> (icon-button) {\n\t\t<span class=\"hljs-selector-tag\">button</span> {\n\t\t\t<span class=\"hljs-keyword\">@layer</span> styles {\n\t\t\t\taspect-ratio: <span class=\"hljs-number\">1</span>;\n\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">9999px</span>;\n\t\t\t}\n\n\t\t\t<span class=\"hljs-attribute\">all</span>: revert-layer <span class=\"hljs-meta\">!important</span>;\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">@scope</span> (toggle-button) {\n\t\t<span class=\"hljs-selector-tag\">button</span> {\n\t\t\t<span class=\"hljs-keyword\">@layer</span> styles {\n\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0.5rem</span>;\n\t\t\t}\n\n\t\t\t<span class=\"hljs-attribute\">all</span>: revert-layer <span class=\"hljs-meta\">!important</span>;\n\t\t}\n\t}\n}\n</code></pre>\n<p>Now whichever element is closer in scope to the shared descendant will have its styles take precedent. For example, here the shape of the button will be a circle and not a squre with rounded corners since <code>icon-button</code> is closer in scope:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">toggle-button</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">icon-button</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">\"Dark Mode\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">aria-pressed</span>=<span class=\"hljs-string\">\"false\"</span>></span>\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">darkmode-icon</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">darkmode-icon</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">icon-button</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">toggle-button</span>></span>\n</code></pre>\n<h3 id=\"solving-the-shortcomings-of-shadow-dom-styles\">Solving the shortcomings of Shadow DOM styles</h3>\n<p>Earlier, we listed some issues we had with Shadow DOM styling. So far, since we’re using a single tree for our elements, we don’t have the problem of not being able to select the descendants of slots or parts.</p>\n<p>The problem of “weak” styles still remain for our new “slotted” or “part” elements (i.e. those which aren’t heavy-handedly preventing styling from subsequent layers), however, there is something we can do which might make that a non-issue—and which could make you consider applying that heavy handed approach to all the elements within these types of components. We have control over which layer we’ve set these styles in, so we can include a layer of shared styles which can serve as a basis for all our components. So instead of setting these styles in the first layer, we could include a <code>reset</code> or <code>defaults</code> layer before that.</p>\n<h3 id=\"how-to-remain-extensible\">How to remain extensible</h3>\n<p>In the past, <a href=\"https://knowler.dev/blog/extensible-web-components\">I’ve written that when you write web components, you should do so in an extensible manner</a> and that means leveraging slots and parts as a default. What I am suggesting here seems to run against that advice.</p>\n<p>The difference here is that since we are in the “Light DOM”, the need for slots/parts to remain extensible doesn’t exist because we’re not working with a tree that is off limits.</p>\n<p>Further, since we can allow layers before our components layer to style elements in our component’s tree, we have a new door to allow our elements to be extensible that doesn’t currently exist with the Shadow DOM (see <a href=\"https://github.com/WICG/webcomponents/issues/909\">the “open-stylable” proposal</a> to see a discussion about changing this).</p>\n<p>There’s one more way that we can allow for modification.</p>\n<h3 id=\"declarative-custom-property-apis\">Declarative custom property APIs</h3>\n<p>With the advent of Cascade Layers, we can use <code>!important</code> to narrow down the available CSS API for elements. Doing so feels kind of wrong—like you are taking something away—but there is an opportunity to be generous. That generosity comes in the form of custom properties.</p>\n<p>We can use custom properties to provide a constrained way of modifying our components. Design system implementors can set the rules for modification.</p>\n<h3 id=\"styling-through-custom-attributes\">Styling through custom attributes</h3>\n<p>Another way we can allow for modification is with custom attributes. This technique is nothing new. It allows consumers to be more declarative with saying what they want.</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@layer</span> components {\n\t<span class=\"hljs-keyword\">@scope</span> (icon-button) {\n\t\t<span class=\"hljs-selector-pseudo\">:where</span>(&#x26;) {\n\t\t\t<span class=\"hljs-attr\">--shape</span>: circle;\n\t\t}\n\n\t\t<span class=\"hljs-selector-pseudo\">:scope</span> {\n\t\t\tcontainer: icon-button;\n\t\t}\n\n\t\t<span class=\"hljs-selector-tag\">button</span> {\n\t\t\t<span class=\"hljs-keyword\">@layer</span> styles {\n\t\t\t\taspect-ratio: <span class=\"hljs-number\">1</span>;\n\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">9999px</span>; <span class=\"hljs-comment\">/* Defaults to a circle */</span>\n\n\t\t\t\t<span class=\"hljs-selector-pseudo\">:where</span>(<span class=\"hljs-selector-attr\">[shape=<span class=\"hljs-string\">\"circle\"</span>]</span>) &#x26; {\n\t\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">9999px</span>;\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-selector-pseudo\">:where</span>(<span class=\"hljs-selector-attr\">[shape=<span class=\"hljs-string\">\"square\"</span>]</span>) &#x26; {\n\t\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0</span>;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t<span class=\"hljs-attribute\">all</span>: revert-layer <span class=\"hljs-meta\">!important</span>;\n\t\t}\n\t}\n}\n</code></pre>\n<p>The downside here is that this is an HTML API and not a CSS API. Some might prefer that, but I personally think that a CSS API is more powerful since it allows other elements to change the styling of your element without the help of JS.</p>\n<h2 id=\"better-custom-properties-with-style-queries\">Better custom properties with style queries</h2>\n<p>Style queries allow us to query a custom property value set on a container. Currently, this is only available in Chromium (in stable). We can use style queries to provide even better custom properties—custom properties that are more declarative in regard to their values. (And we can keep the HTML API too!)</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@layer</span> components {\n\t<span class=\"hljs-keyword\">@scope</span> (icon-button) {\n\t\t<span class=\"hljs-selector-pseudo\">:scope</span> { container: icon-button; }\n\n\t\t<span class=\"hljs-comment\">/* We need to set these values weakly so other elements can override them their own CSS */</span>\n\t\t<span class=\"hljs-selector-pseudo\">:where</span>(&#x26;) { <span class=\"hljs-attr\">--shape</span>: circle; }\n\t\t<span class=\"hljs-selector-pseudo\">:where</span>(<span class=\"hljs-selector-attr\">[shape=<span class=\"hljs-string\">\"square\"</span>]</span>) { <span class=\"hljs-attr\">--shape</span>: square; }\n\n\t\t<span class=\"hljs-selector-tag\">button</span> {\n\t\t\t<span class=\"hljs-keyword\">@layer</span> styles {\n\t\t\t\taspect-ratio: <span class=\"hljs-number\">1</span>;\n\n\t\t\t\t<span class=\"hljs-comment\">/* Set the shape */</span>\n\t\t\t\t<span class=\"hljs-keyword\">@container</span> icon-button style(<span class=\"hljs-attribute\">--shape</span>: circle) {\n\t\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">9999px</span>;\n\t\t\t\t}\n\t\t\t\t<span class=\"hljs-keyword\">@container</span> icon-button style(<span class=\"hljs-attribute\">--shape</span>: square) {\n\t\t\t\t\t<span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0</span>;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t<span class=\"hljs-attribute\">all</span>: revert-layer <span class=\"hljs-meta\">!important</span>;\n\t\t}\n\t}\n}\n</code></pre>\n<h3 id=\"what-should-this-be-used-for\">What should this be used for?</h3>\n<p>You might be looking at this code and be thinking: “that all seems impractical” or that’s a lot of boilerplate. I agree and I disagree. I don’t think this is how you should write all of your styles. It does however work quite well for a design system or for shared components. You probably aren’t introducing new components every day and so the amount of times you’d need to employ this pattern are few and far between.</p>\n<p>If you wanted to colocate these styles with a web component, you can easy do so with <code>document.adoptedStyleSheets</code>. The nice thing about the scoped rule is that it doesn’t matter so much the order you insert the styles into your components layer. You could even make the layer the styles get inserted into configurable.</p>\n<h2 id=\"could-this-be-the-future-of-encapsulated-component-styles\">Could this be the future of encapsulated component styles?</h2>\n<p>By not using the Shadow DOM, we actually have a better styling experience for our components when we leverage Cascade Layers, the forthcoming <code>@scope</code> rule, and style queries. And we might need to rethink our relationship with the notorious <code>!important</code> flag.</p>\n<p>Yes, the Shadow DOM allows for templating and that’s not something we can do in the Light DOM yet, but it could still be on the horizon. If you’re already building Web Components that already don’t use the Shadow DOM, this approach can fill the desire you might have for encapsulated styling.</p>\n<p>Again, this technique uses features that aren’t available broadly yet, but could this be the future?</p>"
}
