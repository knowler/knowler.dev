{
  "id": "01JGQVTVFB3J9M3F7HBN50ASNH",
  "slug": "polyfilling-hidden-until-found",
  "title": "Polyfilling hidden until-found",
  "description": "Exploring what it takes to polyfill the until-found value of the hidden attribute.",
  "publishedAt": "2025-01-04T05:15:31.179Z",
  "published": true,
  "html": "<p>I recently wrote <a href=\"https://12daysofweb.dev/2024/css-content-visibility/\">an article for 12 Days of Web on CSS <code>content-visibility</code></a>.  Something I wanted to highlight in writing that article is that while <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden#the_hidden_until_found_state\">the new HTML feature <code>hidden=until-found</code></a> uses <a href=\"https://12daysofweb.dev/2024/css-content-visibility/#manually-hiding-content-with-hidden\"><code>content-visibility: hidden</code></a> underneath, it works a little differently than how that property works on its own.</p>\n<h2 id=\"content-visibility-hidden-vs-hiddenuntil-found\"><code>content-visibility: hidden</code> vs. <code>hidden=until-found</code></h2>\n<p>On its own, <code>content-visibility: hidden</code> will cause an element’s content to be <em>completely hidden</em>. This means it’s skipped for rendering, ignored by assistive technologies, and <em>not findable</em> using “find-in-page” browser features. The <code>until-found</code> value of the <code>hidden</code> attribute keeps the content findable which makes sense given its name, but otherwise it works the same.</p>\n<p>Something I’d like to underscore is that it’s the <code>hidden=until-found</code> attribute-value pairing that makes content findable — not <code>content-visibility: hidden</code>. This means that in browsers that don’t support <code>hidden=until-found</code> yet, we can’t use <code>content-visibility: hidden</code> as a part of a polyfill. So, how would one polyfill this feature?</p>\n<h2 id=\"hiding-content-while-remaining-findable\">Hiding content while remaining findable</h2>\n<p>Now, while <code>content-visibility: hidden</code> does not keep content findable, <a href=\"https://12daysofweb.dev/2024/css-content-visibility/#letting-the-browser-decide-using-auto\"><code>content-visibility: auto</code></a> does and reflecting on this got me thinking: could it be possible to polyfill <code>hidden=until-found</code> using <code>content-visibility: auto</code>?</p>\n<p>Some differences between the <code>auto</code> and <code>hidden</code> values for the <code>content-visibility</code> property:</p>\n<ol>\n<li><code>auto</code> keeps content accessible whether or not the content is skipped for rendering. <code>hidden</code> always ignores the content in the accessibility tree.</li>\n<li><code>auto</code> skips rendering while <a href=\"https://12daysofweb.dev/2024/css-content-visibility/#what-makes-content-relevant\">the content isn’t relevant</a>. This means that if the content is in the viewport, it will be visible.</li>\n<li>Both <code>auto</code> and <code>hidden</code> apply size, layout, paint, and style <a href=\"https://12daysofweb.dev/2024/css-content-visibility/#css-containment\">containment</a> when the content is hidden. <code>auto</code> drops <em>size</em> containment when the content is visible.</li>\n<li><code>auto</code> keeps content selectable.</li>\n</ol>\n<p>So, we’ve got our grocery list of differences to address by using <code>content-visibility: auto</code>:</p>\n<ol>\n<li>We need the content ignored in the accessibility tree, but the element itself should still be accessible. This means we can’t set <code>aria-hidden=true</code> directly on the element itself.</li>\n<li>We need to visually hide both elements and text nodes.</li>\n<li>We need to ensure size containment is applied while the content is hidden.</li>\n<li>We need to make the content unselectable.</li>\n<li>We need to ensure elements cannot be clicked or focused.</li>\n</ol>\n<p>We can address almost all but the first of these concerns with the following CSS:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-attr\">[hidden=<span class=\"hljs-string\">\"until-found\"</span>]</span> {\n\t<span class=\"hljs-attribute\">display</span>: revert;\n\t<span class=\"hljs-attribute\">content-visibility</span>: auto;\n\t<span class=\"hljs-attribute\">contain</span>: size;\n\tuser-select: none;\n\t<span class=\"hljs-attribute\">color</span>: transparent;\n\n\t> * {\n\t\t<span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">0</span>;\n\t\t<span class=\"hljs-attribute\">pointer-events</span>: none;\n\t}\n}\n</code></pre>\n<iframe src=\"https://knowler.dev/demos/v9-pZyS?codepen\" width=\"100%\" height=\"300px\"></iframe>\n<p>You’ll notice we’re setting <code>display: revert</code>. Wouldn’t that revert back to the user agent style for the <code>hidden</code> attribute which would be <code>display: none</code>? Nope — the <code>hidden</code> attribute is what’s called a presentational hint and the <code>revert</code> keyword reverts presentational hints (as well as non-user agent styles). While this is usually why you’d need to <a href=\"https://mayank.co/blog/revert-layer/#the-nuclear-reset\">exercise caution when using the <code>revert</code> keyword</a>, perhaps even opt-ing for <code>revert-layer</code> instead, this is the perfect use case: we want to revert back to the <em>element’s</em> user agent styles.</p>\n<p>Now, we’re not done yet. And there are improvements to be made.</p>\n<p>Setting <code>color: transparent</code> on the element itself is problematic as it affects <code>currentColor</code> which could be used by other properties of the element (e.g. like its border). Instead it would be great if we could set it on an inner element that wrapped the contents.</p>\n<p>Finally, we want to make some of these styles easy to override. Others should not be an easy override. With the current styles, we need to be very specific about where and when they needed to be loaded to avoid cascading issues.</p>\n<p>To make these improvements and to address the issue of accessibility, we’ll be going into the shadows…</p>\n<h2 id=\"into-the-shadow-dom\">Into the Shadow DOM</h2>\n<p>We can use a shadow root to address both our styling and accessibility concerns — not a phrase you might have expected someone to say about the Shadow DOM.</p>\n<p>First, inside the shadow tree we’ll use a <code>&#x3C;slot></code> element to hide any slotted content from the accessibility tree and we’ll take that content out of the tab order, since <code>&#x3C;slot></code> elements are what’s called a <em>focus navigation scope owner</em>.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">aria-hidden</span>=<span class=\"hljs-string\">true</span> <span class=\"hljs-attr\">tabindex</span>=<span class=\"hljs-string\">-1</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">slot</span>></span>\n</code></pre>\n<p>Why <code>tabindex=-1</code> and <code>aria-hidden=true</code> instead of the <code>inert</code> attribute? The <code>inert</code> attribute does do everything we need: it makes an element and all of its content hidden from the accessibility tree, makes the content unselectable, removes content from the tab order, and prevents content from being clicked or focused. It also does something undesirable for our purposes: it makes content hidden for “find-in-page” features. So, unfortunately, we’ll need to settle with a deconstructed version of it.</p>\n<p>Now, another great advantage of using a <code>&#x3C;slot></code> element is that it’s an encapsulated element inside the tree that with its default styles of <code>display: contents</code> just visually displays all of the contents: text and elements. This is great because we still want the host element to be exposed to the accessibility tree and potentially a part of the tab order. We can also use it to fix some of our styling problems.</p>\n<p>In a stylesheet for our shadow root, we move the <code>color: transparent</code> rule from the host element to the <code>&#x3C;slot></code> element. This means that <code>color</code> and <code>currentColor</code> can be used on the host element, but all slotted content will be transparent.</p>\n<p>Here’s what the stylesheet looks like once we introduce the <code>&#x3C;slot></code> element and adapt it for the shadow DOM:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-pseudo\">:host</span>(<span class=\"hljs-selector-attr\">[hidden=<span class=\"hljs-string\">\"until-found\"</span>]</span>) {\n\t<span class=\"hljs-attribute\">display</span>: revert;\n\t<span class=\"hljs-attribute\">content-visibility</span>: auto;\n\t<span class=\"hljs-attribute\">contain</span>: size;\n\tuser-select: none;\n\t<span class=\"hljs-attribute\">background-clip</span>: initial <span class=\"hljs-meta\">!important</span>;\n\n\tslot {\n\t\t<span class=\"hljs-attribute\">color</span>: transparent;\n\t\t<span class=\"hljs-attribute\">pointer-events</span>: none;\n\t}\n\n\t<span class=\"hljs-selector-pseudo\">::slotted</span>(*) {\n\t\t<span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-meta\">!important</span>;\n\t}\n}\n</code></pre>\n<p>A few notes:</p>\n<ul>\n<li>In order to use the attribute selector for the host element, we need to wrap with the <code>:host()</code> functional pseudo-class. This selector allows us to select the <em>shadow host</em> which in our case will be the element with <code>hidden=until-found</code> set on it. This element is not in the shadow tree, it’s the light DOM element that the shadow tree is attached to. That’s why we need a special selector to target it.</li>\n<li>We’ve moved both the <code>color</code> and <code>pointer-events</code> properties to the <code>&#x3C;slot></code> element. This reduces the restrictions we have on the host element.</li>\n<li>We’re preventing the transparent text from being clipped by setting <code>background-clip: initial !important</code> on the host. This likely isn’t common, but since we’re using <code>color: transparent</code> on a descendant using <code>background-clip: text</code> on the parent with a <code>background-color</code> could expose the content visually.</li>\n<li>Since the slotted content is in the light DOM,  we need to use the <code>::slotted()</code> pseudo-element function with the universal selector to apply to all of the slotted elements. We’ve also made the <code>opacity: 0</code> rule important as shadow DOM styles can be too weak to ensure this applies otherwise, since they’re cascaded before the document styles.</li>\n</ul>\n<p>Now that we have our styles finalized, we can start implementing the polyfilling logic to apply this to any element.</p>\n<h2 id=\"revealing-the-content-when-found\">Revealing the content when found</h2>\n<p>Unfortunately, this is where we have to leave Safari by the wayside, as there’s no good way to observe its “find-in-page” feature. This means that we’re effectively only targeting Firefox.</p>\n<p>While we’re preventing <em>user selection</em> with <code>user-select: none</code>, the “find-in-page” feature in Firefox selects the found text. This means that we can observe if our hidden content has been found with the <code>selectionchange</code> event on the <code>document</code> (or <code>window</code>).</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"selectionchange\"</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =></span> {\n\t<span class=\"hljs-keyword\">const</span> selection = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getSelection</span>();\n\t<span class=\"hljs-keyword\">const</span> foundElement = selection.<span class=\"hljs-property\">anchorNode</span>?.<span class=\"hljs-property\">parentElement</span>.<span class=\"hljs-title function_\">closest</span>(<span class=\"hljs-string\">\"[hidden=until-found]\"</span>);\n\n\t<span class=\"hljs-keyword\">if</span> (foundElement) {\n\t\t<span class=\"hljs-keyword\">const</span> cancelled = !foundElement.<span class=\"hljs-title function_\">dispatchEvent</span>(\n\t\t\t<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Event</span>(<span class=\"hljs-string\">\"beforematch\"</span>, { <span class=\"hljs-attr\">bubbles</span>: <span class=\"hljs-literal\">true</span> });\n\t\t);\n\t\t<span class=\"hljs-keyword\">if</span> (cancelled) <span class=\"hljs-keyword\">return</span>;\n\n\t\tfoundElement.<span class=\"hljs-title function_\">removeAttribute</span>(<span class=\"hljs-string\">\"hidden\"</span>);\n\t\t<span class=\"hljs-keyword\">const</span> slot = foundElement.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">\"slot\"</span>);\n\t\tslot.<span class=\"hljs-title function_\">removeAttribute</span>(<span class=\"hljs-string\">\"tabindex\"</span>);\n\t\tslot.<span class=\"hljs-title function_\">removeAttribute</span>(<span class=\"hljs-string\">\"aria-hidden\"</span>);\n\t}\n});\n</code></pre>\n<p>When the selection changes, we check if the selected content is within an element with <code>hidden=until-found</code>, the <code>beforematch</code> event isn’t cancelled, and if we’re clear, then we start its teardown:</p>\n<ul>\n<li>Removing the <code>hidden</code> attribute (like the actual <code>hidden=until-found</code> feature works), removes all of our styles.</li>\n<li>Then we need to tear down the <code>tabindex</code> and <code>aria-hidden</code> attributes.</li>\n</ul>\n<p>Afterward there is the shadow root leftover and while we can remove that if we replace the host with a shadow-less clone, we’ll lose the selection, which isn’t terribly hard to resolve, but it causes issues with the “find-in-page” feature which put me off from that approach.</p>\n<h2 id=\"applying-the-polyfill\">Applying the polyfill</h2>\n<p>If we start a mutation observer early enough, we can both catch elements as they initially are parsed and later if there are any programmatic changes to the document. We can use this to polyfill the value for the global <code>hidden</code> attribute.</p>\n<p>Here’s the configuration of our observer:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> hiddenUntilFoundObserver = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MutationObserver</span>(callback);\n\nhiddenUntilFoundObserver.<span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-variable language_\">document</span>, {\n\t<span class=\"hljs-attr\">subtree</span>: tree,\n\t<span class=\"hljs-attr\">childList</span>: <span class=\"hljs-literal\">true</span>,\n\t<span class=\"hljs-attr\">attributeFilter</span>: [<span class=\"hljs-string\">\"hidden\"</span>],\n});\n</code></pre>\n<p>Since we’re observing prior to the <code>&#x3C;body></code> element being parsed or constructed, we’ll just observe the <code>document</code> itself. We want to both observe every element mutation and <code>hidden</code> attribute mutations.</p>\n<aside><p>For the purposes of this post, I’m not interested optimizing the performance of this polyfill. If you have any ideas, I’d be happy to hear them though.</p></aside>\n<p>Before we get into the the observer callback, since we’re covering two types of mutations, we’ll need to abstract our shadow root setup code:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> sheet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CSSStyleSheet</span>();\nsheet.<span class=\"hljs-title function_\">replaceSync</span>(<span class=\"hljs-string\">`\n\t:host([hidden=\"until-found\"]) {\n\t\tdisplay: revert;\n\t\tcontent-visibility: auto;\n\t\tcontain: size;\n\t\tuser-select: none;\n\t\tbackground-clip: initial !important;\n\t\n\t\tslot {\n\t\t\tcolor: transparent;\n\t\t\tpointer-events: none;\n\t\t}\n\t\n\t\t::slotted(*) {\n\t\t\topacity: 0 !important;\n\t\t}\n\t}\n`</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addShadow</span>(<span class=\"hljs-params\">element</span>) {\n\t<span class=\"hljs-keyword\">if</span> (element.<span class=\"hljs-property\">shadowRoot</span>) <span class=\"hljs-keyword\">return</span>;\n\telement.<span class=\"hljs-title function_\">attachShadow</span>({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">\"open\"</span> });\n\telement.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-property\">innerHTML</span> = <span class=\"hljs-string\">\"&#x3C;slot aria-hidden=true tabindex=-1>&#x3C;/slot>\"</span>;\n\telement.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-property\">adoptedStyleSheets</span> = [sheet];\n}\n</code></pre>\n<p>If the element already has a shadow root attached this bail early. This is a limitation of making this a generalized approach. It’s not an unsurmountable problem.</p>\n<p>We’re also using the <em>same</em> constructed stylesheet between elements. This is fine since we’re not modifying the stylesheet.</p>\n<p>Now for our callback…</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> hiddenUntilFoundObserver = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MutationObserver</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">entries</span> =></span> {\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> entry <span class=\"hljs-keyword\">of</span> entries) {\n\t\t<span class=\"hljs-keyword\">if</span> (entry.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">\"attributes\"</span> &#x26;&#x26; entry.<span class=\"hljs-property\">target</span>.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">\"hidden\"</span>) === <span class=\"hljs-string\">\"until-found\"</span>) <span class=\"hljs-title function_\">addShadow</span>(entry.<span class=\"hljs-property\">target</span>);\n\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (entry.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">\"childList\"</span>)\n\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> node <span class=\"hljs-keyword\">of</span> entry.<span class=\"hljs-property\">addedNodes</span>)\n\t\t\t\t<span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">getAttribute</span>?.(<span class=\"hljs-string\">\"hidden\"</span>) === <span class=\"hljs-string\">\"until-found\"</span>) <span class=\"hljs-title function_\">addShadow</span>(node);\n\t}\n});\n</code></pre>\n<p>For <code>attributes</code> mutation records, we only need to worry about one element which makes it straightforward to check the value of the <code>hidden</code> attribute. For <code>childList</code> mutation records, the <code>addedNodes</code> could be text nodes, so we need to optionally call the <code>getAttribute()</code> in our check.</p>\n<p>Now, all of the polyfill’s code is written and we just need to feature check if we need the polyfill. In browsers that support the feature we can check if <code>onbeforematch</code> is in the <code>document</code>. We’ll also want to filter out Safari which we’ll just have to do a bit inelgantly just using a supports-check for <code>user-select: none</code> since there’s no way to feature-check “find-in-page.”</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"onbeforematch\"</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable language_\">document</span> || !<span class=\"hljs-variable constant_\">CSS</span>.<span class=\"hljs-title function_\">supports</span>(<span class=\"hljs-string\">\"(user-select: none)\"</span>)) <span class=\"hljs-keyword\">return</span>;\n</code></pre>\n<p>Once that’s in place we’ve got our entire polyfill:</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\"onbeforematch\"</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable language_\">document</span> || !<span class=\"hljs-variable constant_\">CSS</span>.<span class=\"hljs-title function_\">supports</span>(<span class=\"hljs-string\">\"(user-select: none)\"</span>)) <span class=\"hljs-keyword\">return</span>;\n\n\t<span class=\"hljs-keyword\">const</span> sheet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CSSStyleSheet</span>();\n\tsheet.<span class=\"hljs-title function_\">replaceSync</span>(<span class=\"hljs-string\">`\n\t\t:host([hidden=\"until-found\"]) {\n\t\t\tdisplay: revert;\n\t\t\tcontent-visibility: auto;\n\t\t\tcontain: size;\n\t\t\tuser-select: none;\n\t\t\tbackground-clip: initial !important;\n\t\t\n\t\t\tslot {\n\t\t\t\tcolor: transparent;\n\t\t\t\tpointer-events: none;\n\t\t\t}\n\t\t\n\t\t\t::slotted(*) {\n\t\t\t\topacity: 0 !important;\n\t\t\t}\n\t\t}\n\t`</span>);\n\n\t<span class=\"hljs-keyword\">const</span> hiddenUntilFoundObserver = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MutationObserver</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">entries</span> =></span> {\n\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> entry <span class=\"hljs-keyword\">of</span> entries) {\n\t\t\t<span class=\"hljs-keyword\">if</span> (entry.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">\"attributes\"</span> &#x26;&#x26; entry.<span class=\"hljs-property\">target</span>.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">\"hidden\"</span>) === <span class=\"hljs-string\">\"until-found\"</span>) <span class=\"hljs-title function_\">addShadow</span>(entry.<span class=\"hljs-property\">target</span>);\n\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (entry.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">\"childList\"</span>)\n\t\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> node <span class=\"hljs-keyword\">of</span> entry.<span class=\"hljs-property\">addedNodes</span>)\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">getAttribute</span>?.(<span class=\"hljs-string\">\"hidden\"</span>) === <span class=\"hljs-string\">\"until-found\"</span>) <span class=\"hljs-title function_\">addShadow</span>(node);\n\t\t}\n\t});\n\t\n\thiddenUntilFoundObserver.<span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-variable language_\">document</span>, {\n\t\t<span class=\"hljs-attr\">subtree</span>: tree,\n\t\t<span class=\"hljs-attr\">childList</span>: <span class=\"hljs-literal\">true</span>,\n\t\t<span class=\"hljs-attr\">attributeFilter</span>: [<span class=\"hljs-string\">\"hidden\"</span>],\n\t});\n\n\t<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"selectionchange\"</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =></span> {\n\t\t<span class=\"hljs-keyword\">const</span> selection = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getSelection</span>();\n\t\t<span class=\"hljs-keyword\">const</span> foundElement = selection.<span class=\"hljs-property\">anchorNode</span>?.<span class=\"hljs-property\">parentElement</span>.<span class=\"hljs-title function_\">closest</span>(<span class=\"hljs-string\">\"[hidden=until-found]\"</span>);\n\t\n\t\t<span class=\"hljs-keyword\">if</span> (foundElement) {\n\t\t\t<span class=\"hljs-keyword\">const</span> cancelled = !foundElement.<span class=\"hljs-title function_\">dispatchEvent</span>(\n\t\t\t\t<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Event</span>(<span class=\"hljs-string\">\"beforematch\"</span>, { <span class=\"hljs-attr\">bubbles</span>: <span class=\"hljs-literal\">true</span> });\n\t\t\t);\n\t\t\t<span class=\"hljs-keyword\">if</span> (cancelled) <span class=\"hljs-keyword\">return</span>;\n\t\n\t\t\tfoundElement.<span class=\"hljs-title function_\">removeAttribute</span>(<span class=\"hljs-string\">\"hidden\"</span>);\n\t\t\t<span class=\"hljs-keyword\">const</span> slot = foundElement.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">\"slot\"</span>);\n\t\t\tslot.<span class=\"hljs-title function_\">removeAttribute</span>(<span class=\"hljs-string\">\"tabindex\"</span>);\n\t\t\tslot.<span class=\"hljs-title function_\">removeAttribute</span>(<span class=\"hljs-string\">\"aria-hidden\"</span>);\n\t\t}\n\t});\n\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addShadow</span>(<span class=\"hljs-params\">element</span>) {\n\t\t<span class=\"hljs-keyword\">if</span> (element.<span class=\"hljs-property\">shadowRoot</span>) <span class=\"hljs-keyword\">return</span>;\n\t\telement.<span class=\"hljs-title function_\">attachShadow</span>({ <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">\"open\"</span> });\n\t\telement.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-property\">innerHTML</span> = <span class=\"hljs-string\">\"&#x3C;slot aria-hidden=true tabindex=-1>&#x3C;/slot>\"</span>;\n\t\telement.<span class=\"hljs-property\">shadowRoot</span>.<span class=\"hljs-property\">adoptedStyleSheets</span> = [sheet];\n\t}\n})();\n</code></pre>\n<p>And here it is in action:</p>\n<iframe src=https://knowler.dev/demos/5gLfaym?codepen width=100% height=300></iframe>\n<h2 id=\"summary-of-limitations\">Summary of limitations</h2>\n<p>As mentioned, this does not work in Safari and you don’t need it in Chrome.</p>\n<p>Due to issues with observing selection within shadow roots in Firefox, there’s no way we can make the polyfill work inside shadow roots.</p>\n<p>And again, this also doesn’t work for elements that already have a shadow root.</p>\n<h2 id=\"why-even\">Why even?</h2>\n<p>Given the limitations and especially the fact that this polyfill only applies to one browser, why bother polyfilling this? Well, to be completely honest I don’t find it worth polyfilling — especially since it would be quite easy to progressively enhance <code>hidden=until-found</code> usage. This was an interesting exercise in exploring <em>findability</em> in the browser. It’s something that authors don’t have <em>direct</em> control over. It takes a very thought out concoction of CSS and shadow DOM to even mimic something that is based on it. Perhaps this could be something that authors had greater control over in the future. Another part of browsers to unearth in making the platform extensible?</p>\n<h2 id=\"contribute\">Contribute</h2>\n<p>If you want to use the final polyfill or contribute,  you can do so on GitHub at <a href=\"https://github.com/knowler/hidden-until-found-polyfill\">knowler/hidden-until-found-polyfill</a>.</p>"
}
